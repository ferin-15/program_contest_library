\documentclass[11pt,a4paper]{jsarticle}

\usepackage{amsmath,amssymb}
\usepackage{bm}
\usepackage[dvipdfmx]{graphicx}
\usepackage{ascmac}
\usepackage{listings,jlisting}

\lstset{%
  language={C++},
  basicstyle={\small},%
  identifierstyle={\small},%
  commentstyle={\small\itshape},%
  keywordstyle={\small\bfseries},%
  ndkeywordstyle={\small},%
  stringstyle={\small\ttfamily},
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},%
  numbers=left,%
  xrightmargin=0zw,%
  xleftmargin=3zw,%
  numberstyle={\scriptsize},%
  stepnumber=1,
  numbersep=1zw,%
  lineskip=-0.5ex%
}

\title{title}
\author{16268035 鈴木悠馬}
\date{\today}

\begin{document}

幾何
\begin{lstlisting}
  const double EPS = 1e-8;
  const double INF = 1e12;

  //point
  typedef complex<double> P;
  namespace std {
  	bool operator < (const P& a, const P& b) {
  		return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);
  	}
  	bool cmp_y(const P &a, const P &b){
  		return a.imag() != b.imag() ? a.imag() < b.imag() : a.real() < b.real();
  	}
  }
  double cross(const P& a, const P& b) {
  	return imag(conj(a)*b);
  }
  double dot(const P& a, const P& b) {
  	return real(conj(a)*b);
  }

  // line
  struct L : public vector<P> {
  	L(const P& a, const P& b) {
  		push_back(a); push_back(b);
  	}
  };

  // polygon
  typedef vector<P> G;

  // circle
  struct C {
  	P p; double r;
  	C(const P& p, double r) : p(p), r(r) {}
  };
\end{lstlisting}

点と線分
\begin{lstlisting}
  //point
  typedef complex<double> P;
  namespace std {
  	bool operator < (const P& a, const P& b) {
  		return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);
  	}
  }
  double cross(const P& a, const P& b) {
  	return imag(conj(a)*b);
  }
  double dot(const P& a, const P& b) {
  	return real(conj(a)*b);
  }
  // line
  struct L : public vector<P> {
  	L(const P& a, const P& b) {
  		push_back(a); push_back(b);
  	}
  };

  int ccw(P a, P b, P c) {
    b -= a; c -= a;
    if (cross(b, c) > 0)   return +1;       // counter clockwise
    if (cross(b, c) < 0)   return -1;       // clockwise
    if (dot(b, c) < 0)     return +2;       // c--a--b on line
    if (norm(b) < norm(c)) return -2;       // a--b--c on line
    return 0;								  // a--c--b on line
  }

  //Lが直線,Sが線分
  bool intersectLL(const L &l, const L &m) {
    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel
           abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line
  }
  bool intersectLS(const L &l, const L &s) {
    return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l
           cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l
  }
  bool intersectLP(const L &l, const P &p) {
    return abs(cross(l[1]-p, l[0]-p)) < EPS;
  }
  bool intersectSS(const L &s, const L &t) {
    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&
           ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;
  }
  bool intersectSP(const L &s, const P &p) {
    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality
  }

  P projection(const L &l, const P &p) {
  	double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);
  	return l[0] + t*(l[0]-l[1]);
  }
  P reflection(const L &l, const P &p) {
  	return p + (double)2 * (projection(l, p) - p);
  }
  double distanceLP(const L &l, const P &p) {
  	return abs(p - projection(l, p));
  }
  double distanceLL(const L &l, const L &m) {
  	return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);
  }
  double distanceLS(const L &l, const L &s) {
  	if (intersectLS(l, s)) return 0;
  	return min(distanceLP(l, s[0]), distanceLP(l, s[1]));
  }
  double distanceSP(const L &s, const P &p) {
  	const P r = projection(s, p);
  	if (intersectSP(s, r)) return abs(r - p);
  	return min(abs(s[0] - p), abs(s[1] - p));
  }
  double distanceSS(const L &s, const L &t) {
  	if (intersectSS(s, t)) return 0;
  		return min({distanceSP(s, t[0]), distanceSP(s, t[1]), distanceSP(t, s[0]), distanceSP(t, s[1])});
  }
  P crosspoint(const L &l, const L &m) {
    double A = cross(l[1] - l[0], m[1] - m[0]);
    double B = cross(l[1] - l[0], l[1] - m[0]);
    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line
    if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!
    return m[0] + B / A * (m[1] - m[0]);
  }
\end{lstlisting}

多角形
\begin{lstlisting}
  // polygon
  typedef vector<P> G;

  P extreme(const vector<P> &po, const L &l) {
    int k = 0;
    for (int i = 1; i < po.size(); ++i)
      if (dot(po[i], l[1]-l[0]) > dot(po[k], l[1]-l[0])) k = i;
    return po[k];
  }

  enum { OUT, ON, IN };
  int contains(const G& po, const P& p) {
    bool in = false;
    for (int i = 0; i < po.size(); ++i) {
    	P a = po[i] - p, b = po[(i+1)%po.size()] - p;
      if (imag(a) > imag(b)) swap(a, b);
      if (imag(a) <= 0 && 0 < imag(b))
        if (cross(a, b) < 0) in = !in;
      if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;
    }
    return in ? IN : OUT;
  }

  double area2(const G& po) {
  	double A = 0;
    	for (int i = 0; i < po.size(); ++i)
      	A += cross(po[i], po[(i+1)%po.size()]);
    //最後にまとめて割る2
    return A/2;
  }

  bool isconvex(const G &p) {
  	int n = p.size();
  	if(cross(p[0]-p[n-1],p[n-2]-p[n-1]) < 0) return false;
  	for(int i = 1; i < n-1; ++i) {
  		if(cross(p[i+1]-p[i],p[i-1]-p[i]) < 0) return false;
  	}
  	return true;
  }

  G convex_hull(G ps) {
    int n = ps.size(), k = 0;
    sort(ps.begin(), ps.end(), cmp_y);
    G r(2*n);
    for(int i = 0; i < n; i++){
      while(k>1 && cross(r[k-1]-r[k-2],ps[i]-r[k-2]) < -EPS)k--;
      r[k++] = ps[i];
    }
    for(int i = n-2, t = k; i >= 0; i--){
      while(k>t && cross(r[k-1]-r[k-2],ps[i]-r[k-2]) < -EPS)k--;
      r[k++] = ps[i];
    }
    r.resize(k-1);
    return r;
  }

  // caliper
  double convex_diameter(const G &pt) {
  	const int n = pt.size();
  	if(n <= 1) return 0;
  	if(n == 2) return abs(pt[0]-pt[1]);

  	int i = 0, j = 0;
  	for(int k = 0; k < n; ++k){
  		if(!(pt[i] < pt[k])) i = k;
  		if(pt[j] < pt[k]) j = k;
  	}

  	double res = 0;
  	int si = i, sj = j;
  	while(i != sj || j != si) {
  		res = max(res, abs(pt[i]-pt[j]));
  		if(cross(pt[(i+1)%n]-pt[i],pt[(j+1)%n]-pt[j]) < 0) i = (i+1)%n;
  		else j = (j+1)%n;
  	}
  	return res;
  }

  // 凸多角形poをlで切った左の多角形を返す
  G convex_cut(const G& po, const L& l) {
    G Q;
    for (int i = 0; i < po.size(); ++i) {
    	P A = po[i], B = po[(i+1)%po.size()];
      if (ccw(l[0], l[1], A) != -1) Q.push_back(A);
    	if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0) {
    		Q.push_back(crosspoint(L(A, B), l));
    	}
    }
    return Q;
  }

  //最近点対 嘘
  double closestPair(G p, int flag=1) {
  	if(flag) sort(p.begin(), p.end());
  	int n = p.size(), s = 0, m=n/2;
  	if(n<=1) return INF;
  	G b(begin(p), begin(p)+m), c(begin(p)+m, end(p)), e;
  	double x = p[m].real(), d=min(closestPair(b, 0), closestPair(c, 0));
  	sort(p.begin(), p.end(), cmp_y);
  	for(int i=0; i<n; ++i) {
  		if(abs(real(p[i])-x) >= d) continue;
  		for(int j=0; j<e.size(); ++j) {
  			if(imag(p[i]-e[e.size()-1-j]) >= d) break;
  			d = min(d, abs(p[i]-e[e.size()-1-j]));
  		}
  		e.push_back(p[i]);
  	}
  	return d;
  }
\end{lstlisting}

円
\begin{lstlisting}
  // circle
  struct C {
  	P p; double r;
  	C(const P& p, double r) : p(p), r(r) {}
  };

  int intersectCC(const C& a, const C& b) {
  	double dist = sqrt(norm(a.p-b.p)), r1 = a.r + b.r, r2 = abs(a.r - b.r);
  	if(r1 < dist) return 4;		//外
  	if(dist == r1) return 3;	//外接
  	if(r2 < dist && dist < r1) return 2; //2点で交わる
  	if(dist == r2) return 1; //内接
  	return 0;	//内包
  }

  vector<P> crossPointCL(C c, L l) {
  	double d = distanceLP(l, c.p), r = c.r;
  	P m = projection(l, c.p);
  	P x = sqrt(r*r-d*d)/abs(l[1]-l[0])*(l[1]-l[0]);
  	vector<P> ret(2,m);
  	ret[0] -= x;
  	ret[1] += x;
  	sort(ret.begin(), ret.end());	//!!!
  	return ret;
  }

  vector<P> crossPointCC(C a, C b) {
  	double d = abs(a.p-b.p);
  	double t = (a.r*a.r-b.r*b.r+d*d)/2/d, h = sqrt(a.r*a.r-t*t);
  	P m = t/abs(b.p-a.p)*(b.p-a.p)+a.p;
  	P n = n_vector(a.p-b.p);
  	vector<P> ret(2, m);
  	ret[0] -= h*n;
  	ret[1] += h*n;
  	sort(ret.begin(), ret.end());	//!!!
  	return ret;
  }

  //接線
  vector<P> tangentLC(P p, C c) {
  	C c2 = C((p+c.p)/2.0, abs(p-c.p)/2.0);
  	return crossPointCC(c, c2);
  }

  //共通接線
  vector<P> commonTangent(C a, C b) {
  	vector<P> ret, cp;
  	if(a.r == b.r) {
  		P n = n_vector(b.p-a.p);
  		ret.push_back(P{a.p+a.r*n});
  		ret.push_back(P{a.p-a.r*n});
  	}
  	P i = (a.p*b.r+b.p*a.r)/(a.r+b.r);
    	if(abs(a.p-b.p) > a.r+b.r){
      	cp = tangentLC(i,a);
      	for(int i = 0; i < 2; ++i) ret.push_back(cp[i]);
      	if(a.r != b.r){
        		P e = (a.p*b.r-b.p*a.r)/(b.r-a.r);
        		cp = tangentLC(e,a);
        		for(int i = 0; i < 2; ++i) ret.push_back(cp[i]);
      	}
    	}else if(abs(a.p-b.p) == a.r+b.r){
      	cp = tangentLC(i,a);
      	ret.push_back(cp[0]);
      	if(a.r != b.r){
      		P e = (a.p*b.r-b.p*a.r)/(b.r-a.r);
        		cp = tangentLC(e,a);
        		for(int i = 0; i < 2; ++i) ret.push_back(cp[i]);
      	}
    	}else if(abs(a.p-b.p) > abs(a.r-b.r)){
      	if(a.r != b.r){
      		P e = (a.p*b.r-b.p*a.r)/(b.r-a.r);
        		cp = tangentLC(e,a);
        		for(int i = 0; i < 2; ++i) ret.push_back(cp[i]);
      	}
    	}else if(abs(a.p-b.p) == abs(a.r-b.r)){
      	P e = (a.p*b.r-b.p*a.r)/(b.r-a.r);
      	cp = tangentLC(e,a);
      	ret.push_back(cp[0]);
    	}
  	sort(ret.begin(), ret.end());
    	return ret;
  }

  /*
  3点が与えられたときに円を求める
  返り値は{中心のx座標、y座標、半径}
  3点が直線上に並んでいるときは{0, 0, -1}を返す
  */
  C calcCircle(int x1, int y1, int x2, int y2, int x3, int y3) {
    long ox, oy, a, b, c, d;
    long r1, r2, r3;

    a = x2 - x1;
    b = y2 - y1;
    c = x3 - x1;
    d = y3 - y1;

    int cx, cy, r;
    if ((a && d) || (b && c)) {
      ox = x1 + (d * (a * a + b * b) - b * (c * c + d * d)) / (a * d - b * c) / 2;
      if (b) {
        oy = (a * (x1 + x2 - ox - ox) + b * (y1 + y2)) / b / 2;
      } else {
        oy = (c * (x1 + x3 - ox - ox) + d * (y1 + y3)) / d / 2;
      }
      r1 = sqrt((ox - x1) * (ox - x1) + (oy - y1) * (oy - y1));
      r2 = sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2));
      r3 = sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3));
      cx = ox;
      cy = oy;
      r = (r1 + r2 + r3) / 3;
      return {P{cx, cy}, r};
    }

    return {P{0, 0}, -1};
  }
\end{lstlisting}

\begin{lstlisting}
  // Binary Indexed Tree max
  #define MAX_N 100000
  int n;
  int bit[MAX_N];

  // a-1の位置にwを更新
  void add(int a, int w) {
    for (int x = a; x < n; x |= x + 1) {
      if (bit[x] < w)
        bit[x] = w;
    }
  }

  // 0 から a-1 までの最大値を求める
  int maximum(int a) {
    int ret = -INF;
    for (int x = a - 1; x >= 0; x = (x & (x + 1)) - 1)
      ret = max(ret, bit[x]);
    return ret;
  }
\end{lstlisting}

\begin{lstlisting}
  bool prime[1000000];
  memset(prime, true, sizeof(prime));
  prime[0] = prime[1] = false;
  for (int i = 2; i * i <= 1000000; i++) {
  	if (prime[i]) {
  		for (int j = 2 * i; j <= 1000000; j += i) {
  			prime[j] = false;
  		}
  	}
  }
\end{lstlisting}

lca
\begin{lstlisting}
  VI G[MAX_N];  //グラフの隣接リスト
  int root = 0;     //根のノード

  int parent[MAX_LOG_N][MAX_N];
  int depth[MAX_N];

  void dfs(int v, int p, int d) {
    parent[0][v] = p;
    depth[v] = d;
    REP(i, G[v].size()) if(G[v][i] != p) dfs(G[v][i], v, d+1);
  }

  //初期化 O(logn)
  void init(int n) {
    dfs(root, -1, 0);
    REP(k, MAX_LOG_N-1) REP(v, n) {
      if(parent[k][v] < 0) parent[k+1][v] = -1;
      else parent[k+1][v] = parent[k][parent[k][v]];
    }
  }

  // uとvのlcaを求める
  int lca(int u, int v) {
    if(depth[u] > depth[v]) swap(u, v);
    REP(k, MAX_LOG_N) {
      if((depth[v]-depth[u]) >> k & 1) v = parent[k][v];
    }
    if(u == v) return u;
    for(int k = MAX_LOG_N-1; k>=0; k--) {
      if(parent[k][u] != parent[k][v]) {
        u = parent[k][u];
        v = parent[k][v];
      }
    }
    return parent[0][u];
  }
\end{lstlisting}

binary pow
\begin{lstlisting}
  //二分累乗法 xのe乗
  ll binpow(ll x, ll e) {
    ll a = 1, p = x;
    while(e > 0) {
      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}
      else {a = (a*p) % MOD; e--;}
    }
    return a % MOD;
  }
\end{lstlisting}

素因数分解
\begin{lstlisting}
  // first: 素因数 second: firstが何個あるか O(nsqrt(n))
  map<ll, ll> v;
  ll a = 2;
  while(x >= a*a) {
    if(x % a == 0) {
      v[a]++;
      x /= a;
    } else {
      a++;
    }
  }
  v[x]++;
\end{lstlisting}

string split
\begin{lstlisting}
  // sepで区切る
  vector<string> split(const string &str, char sep)
  {
    vector<string> v;
    auto first = str.begin();
    while( first != str.end() ) {
      auto last = first;
      while( last != str.end() && *last != sep ) ++last;
      v.push_back(std::string(first, last));
      if( last != str.end() ) ++last;
      first = last;
    }
    return v;
  }
\end{lstlisting}

トポロジカルソート
\begin{lstlisting}
  //グラフの隣接リスト
  VI g[100010];
  //頂点の入次数を管理
  int h[100010];
  signed main(void)
  {
    //頂点数v、辺の数e
    int v, e;
    cin >> v >> e;
    REP(i, e) {
      int s, t;
      cin >> s >> t;
      //頂点sから頂点tへの有向辺
      g[s].push_back(t);
      h[t]++;
    }

    //入次数が0の頂点の集合
    stack<int> st;

    //入次数が0の頂点であればstに追加
    REP(i, v) if(h[i] == 0) st.push(i);

    //ソートされた後のグラフ
    VI ans;
    //stがなくなるまでループ
    while(st.size()) {
      //stの集合のから一つ取り出す
      int i = st.top(); st.pop();
      ans.push_back(i);
      for(auto& j: g[i]) {
        //隣接する頂点の入次数をマイナス1
        h[j]--;
        //これによって入次数が0になればstに追加
        if(h[j] == 0) st.push(j);
      }
    }

    //ansを順に出力
    for(int i: ans) cout << i << endl;

    return 0;
  }
\end{lstlisting}

構文解析
\begin{lstlisting}
  typedef string::const_iterator State;
  class ParseError {};
  int expression(State&);
  int term(State&);
  int number(State&);
  int factor(State&);

  int expression(State &begin) {
  	int ret = term(begin);
  	while(1) {
  		if(*begin == '+') {
  			begin++;
  			ret += term(begin);
  		} else if(*begin == '-') {
  			begin++;
  			ret -= term(begin);
  		} else {
  			break;
  		}
  	}
  	return ret;
  }

  int term(State &begin) {
  	int ret = factor(begin);
  	while(1) {
  		if(*begin == '*') {
  			begin++;
  			ret *= factor(begin);
  		} else if(*begin == '/') {
  			begin++;
  			ret /= factor(begin);
  		} else {
  			break;
  		}
  	}
  	return ret;
  }

  int factor(State &begin) {
  	if(*begin == '(') {
  		begin++;
  		int ret = expression(begin);
  		begin++;
  	} else {
  		return number(begin);
  	}
  }

  int number(State &begin) {
  	int ret = 0;
  	while(isdigit(*begin)) {
  		ret *= 10;
  		ret += *begin - '0';
  		begin++;
  	}
  	return ret;
  }

  signed main(void)
  {
  	string s;
  	getline(cin, s);

  	//REP(i, n) REP(j, n)
  	State begin = s.begin();
  	int ans = expression(begin);
  	cout << ans << endl;

  	return 0;
  }
\end{lstlisting}

座圧
\begin{lstlisting}
  int b[100010];
  map<ll, ll> mp;
  vector<ll> c(n), d(n);
  REP(i, n) {
    mp[b[i]] = 0;
    d[i] = b[i];
  }
  int rank = 0, cnt = 0;
  for(auto& i: mp) i.second = rank++;
  for(auto& i: d) {
    c[cnt] = mp[i];
    cnt++;
  }
\end{lstlisting}

平衡二分探索木
\begin{lstlisting}
  unsigned xorShift() {
  	static unsigned z = time(NULL);
  	z ^= z << 13; z ^= z >> 17; z ^= z << 5;
  	return z;
  }

  struct node {
    int val;
    node *ch[2];
    int pri;
    int cnt; //部分木のサイズ
    int sum; //部分木の値の和

    node(int v, double p): val(v),pri(p),cnt(1),sum(v) {
      ch[0] = ch[1] = nullptr;
    }
  };

  int count(node *t) {return t == nullptr ? 0: t->cnt;}
  int sum(node *t) {return t == nullptr ? 0: t->sum;}

  node *update(node *t) {
    t->cnt = count(t->ch[0]) + count(t->ch[1]) + 1;
    t->sum = sum(t->ch[0]) + sum(t->ch[1]) + t->val;
    return t;
  }

  // b=0で左回転、b=1で右回転
  node *rotate(node *t, int b) {
    node *s = t->ch[1-b];
    t->ch[1-b] = s->ch[b];
    s->ch[b] = t;
    update(t);
    update(s);
    return s;
  }

  node *insert(node *t, int val, int pri) {
    if(t == nullptr) return new node(val, pri);
    else if(val == t->val) return t;
    else if(val < t->val) {
      t->ch[0] = insert(t->ch[0], val, pri);
      if(t->pri > t->ch[0]->pri) {
        t = rotate(t, 1);
      }
    } else{
      t->ch[1] = insert(t->ch[1], val, pri);
      if(t->pri > t->ch[1]->pri) {
        t = rotate(t, 0);
      }
    }
    return update(t);
  }

  node *erase(node *t, int x) {
    if (t->val == x) {
      if (t->ch[0] && t->ch[1]) {
        if (t->ch[0]->pri < t->ch[1]->pri) {
          t = rotate(t, 1);
          t->ch[1] = erase(t->ch[1], x);
          return update(t);
        } else {
          t = rotate(t, 0);
          t->ch[0] = erase(t->ch[0], x);
          return update(t);
        }
      } else {
        return t->ch[0] ? t->ch[0] : t->ch[1];
      }
    } else if (x < t->val) {
      t->ch[0] = erase(t->ch[0], x);
    } else {
      t->ch[1] = erase(t->ch[1], x);
    }
    return update(t);
  }

  int level(node *t, int k) {
    if(k < count(t->ch[0])) return level(t->ch[0], k);
    if(k == count(t->ch[0])) return t->val;
    return level(t->ch[1], k-count(t->ch[0])-1);
  }
\end{lstlisting}

サイコロ
\begin{lstlisting}
  struct Dice{
    //top, front, right, left, back, bottom
    int side[6];
    Dice(){}
    Dice(int s[]){
      for(int i=0; i<6; ++i) side[i] = s[i];
    }

    void rotate(int op){
      int tmp = ' ';
      //右に倒す
      if(op==0){
        tmp = side[0];
        side[0] = side[3];
        side[3] = side[5];
        side[5] = side[2];
        side[2] = tmp;
      }

      //前に倒す
      if(op==1){
        tmp = side[0];
        side[0] = side[4];
        side[4] = side[5];
        side[5] = side[1];
        side[1] = tmp;
      }

      //左に倒す
      if(op==2){
        tmp = side[0];
        side[0] = side[2];
        side[2] = side[5];
        side[5] = side[3];
        side[3] = tmp;
      }

      //後ろに倒す
      if(op==3){
        tmp = side[0];
        side[0] = side[1];
        side[1] = side[5];
        side[5] = side[4];
        side[4] = tmp;
      }

      //topとbottomを軸に右回転
      if(op==4){
        tmp = side[1];
        side[1] = side[2];
        side[2] = side[4];
        side[4] = side[3];
        side[3] = tmp;
      }

      //topとbottomを軸に左回転
      if(op==5){
        tmp = side[1];
        side[1] = side[3];
        side[3] = side[4];
        side[4] = side[2];
        side[2] = tmp;
      }
    }
  };

  //24通りのサイコロを生成する
  Dice initDice, dice[24];
  void makeDice(){
    int tmpNum[] = {1,2,3,4,5,6};
    initDice = Dice(tmpNum);

    for(int i=0; i<24; ++i){
      if(i==4) initDice.rotate(1);
      if(i==8) initDice.rotate(1);
      if(i==12)initDice.rotate(1);
      if(i==16){
        initDice.rotate(1);
        initDice.rotate(0);
      }
      if(i==20){
        initDice.rotate(2);
        initDice.rotate(2);
      }
      initDice.rotate(4);
      dice[i] = initDice;
    }
  }

  // d[top][front] front, right, back, left
  // 問題のdiceの設定とあっているか確認すること！！！！！
  int d[6][6][4] = {
    {{-1, -1, -1, -1}, {2, 4, 5, 3}, {3, 2, 4, 5}, {4, 5, 3, 2}, {5, 3, 2, 4}, {-1, -1, -1, -1}}
    ,{{1, 3, 6, 4}, {-1, -1, -1, -1}, {3, 6, 4, 1}, {4, 1, 3, 6}, {-1, -1, -1, -1}, {6, 4, 1, 3}}
    ,{{1, 5, 6, 2}, {2, 1, 5, 6}, {-1,-1,-1,-1}, {-1,-1,-1,-1}, {5, 6, 2, 1}, {6, 2, 1, 5}}
    ,{{1, 2, 6, 5}, {2, 6, 5, 1}, {-1,-1,-1,-1}, {-1,-1,-1,-1}, {5, 1, 2, 6}, {6, 5, 1, 2}}
    ,{{1, 4, 6, 3}, {-1,-1,-1,-1}, {3, 1, 4, 6}, {4, 6, 3, 1}, {-1,-1,-1,-1}, {6, 3, 1, 4}}
    ,{{-1,-1,-1,-1}, {2, 3, 5, 4}, {3, 5, 4, 2}, {4, 2, 3, 5}, {5, 4, 2, 3}, {-1,-1,-1,-1}}};
\end{lstlisting}

中国人配達問題
\begin{lstlisting}
  int d[17][17], f[17];
  signed main(void)
  {
    int v, e, tot = 0;
    cin >> v >> e;
    REP(i, v) REP(j, v) d[i][j] = INF;
    REP(i, e) {
      int a, b, c;
      cin >> a >> b >> c;
      d[a][b] = min(d[a][b], c); d[b][a] = min(d[b][a], c);
      f[a]++; f[b]++;
      tot += c;
    }
    VI o;
    REP(i, v) if(f[i]%2) o.push_back(i);
    REP(k, v) REP(i, v) REP(j, v) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    int dp[1<<16], os = o.size();
    fill(dp, dp+(1<<os), INF);
    dp[0] = 0;
    REP(s, 1<<os) REP(i, os) if(~s>>i&1) REP(j, i) if(~s>>j&1) {
      dp[s|1<<i|1<<j] = min(dp[s|1<<i|1<<j], dp[s] + d[o[i]][o[j]]);
    }
    cout << tot + dp[(1<<os)-1] << endl;
    return 0;
  }
\end{lstlisting}

編集距離
\begin{lstlisting}
  int dp[1010][1010];
  signed main(void)
  {
    string s, t;
    cin >> t >> s;
    const int n = s.size(), m = t.size();
    REP(i, n+1) REP(j, m+1) {
      if(i == 0) dp[i][j] = j;
      else if(j == 0) dp[i][j] = i;
      else {
        if(s[i-1] == t[j-1]) {
          dp[i][j] = min({dp[i-1][j-1], dp[i-1][j]+1, dp[i][j-1]+1});
        } else {
          dp[i][j] = min({dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1]+1});
        }
      }
    }
    cout << dp[n][m] << endl;
    return 0;
  }
\end{lstlisting}

\begin{lstlisting}
  int n, h[100010], l[100010], r[100010], st[100010];
  signed main(void)
  {
    // i番目の高さがh[i]のヒストグラム中で最大の長方形の面積
    cin >> n;
    REP(i, n) cin >> h[i];
    int t = 0;
    REP(i, n) {
      while(t>0 && h[st[t-1]] >= h[i]) t--;
      l[i] = t == 0 ? 0 : (st[t-1]+1);
      st[t++] = i;
    }
    t = 0;
    for(int i=n-1; i>=0; --i) {
      while(t > 0 && h[st[t-1]] >= h[i]) t--;
      r[i] = t == 0 ? n : st[t-1];
      st[t++] = i;
    }
    ll ret = 0;
    REP(i, n) ret = max(ret, (ll)h[i]*(r[i]-l[i]));
    cout << ret << endl;
    return 0;
  }
\end{lstlisting}

\begin{lstlisting}
  int n, c[1500][1500], dp[1500][1500], l[1500], r[1500], st[1500];
  signed main(void)
  {
    // h * w の0,1からなる行列の中で、0のみを使ってできる最大の長方形の面積
    // O(HW)
    int H, W;
    cin >> H >> W;
    REP(i, H) REP(j, W) cin >> c[i][j];

    REP(i, W) {
      int cnt = 1;
      REP(j, H) {
        if(!c[j][i]) {
          dp[j][i] = cnt;
          cnt++;
        } else {
          dp[j][i] = 0;
          cnt = 1;
        }
      }
    }
    ll ret = 0;
    REP(j, H) {
      int t = 0;
      REP(i, W) {
        while(t>0 && dp[j][st[t-1]] >= dp[j][i]) t--;
        l[i] = t == 0 ? 0 : (st[t-1]+1);
        st[t++] = i;
      }
      t = 0;
      for(int i=W-1; i>=0; --i) {
        while(t > 0 && dp[j][st[t-1]] >= dp[j][i]) t--;
        r[i] = t == 0 ? n : st[t-1];
        st[t++] = i;
      }
      REP(i, W) ret = max(ret, (ll)dp[j][i]*(r[i]-l[i]));
    }
    cout << ret << endl;
    return 0;
  }
\end{lstlisting}

個数制限付きナップザック
\begin{lstlisting}
  int dp[10010];
  int v[105], w[105], m[105];
  signed main(void)
  {
    int n, W;
    cin >> n >> W;
    REP(i, n) cin >> v[i] >> w[i] >> m[i];
    REP(i, n) {
      int num = m[i];
      for(int k=1; num > 0; k <<= 1) {
        int mu = min(k, num);
        //ダブリング
        for(int j=W; j>=w[i]*mu; --j) {
          dp[j] = max(dp[j], dp[j-w[i]*mu]+v[i]*mu);
        }
        num -= mu;
      }
    }
    cout << dp[W] << endl;
    return 0;
  }

\end{lstlisting}

\end{document}
